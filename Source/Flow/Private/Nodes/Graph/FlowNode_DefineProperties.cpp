// Copyright https://github.com/MothCocoon/FlowGraph/graphs/contributors

#include "Nodes/Graph/FlowNode_DefineProperties.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(FlowNode_DefineProperties)

UFlowNode_DefineProperties::UFlowNode_DefineProperties(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
#if WITH_EDITOR
	NodeDisplayStyle = FlowNodeStyle::Terminal;
	Category = TEXT("Graph");
#endif

	InputPins.Empty();
	OutputPins.Empty();

	AllowedSignalModes = {EFlowSignalMode::Enabled, EFlowSignalMode::Disabled};
}

bool UFlowNode_DefineProperties::TryFindPropertyByRemappedPinName(
	const FName& RemappedPinName,
	const FProperty*& OutFoundProperty,
	TInstancedStruct<FFlowDataPinProperty>& OutFoundInstancedStruct,
	EFlowDataPinResolveResult& InOutResult) const
{
	// The start node stores its properties in instanced structs in an array, so look there first

	for (const FFlowNamedDataPinProperty& NamedProperty : NamedProperties)
	{
		if (NamedProperty.Name == RemappedPinName && NamedProperty.IsValid())
		{
			OutFoundInstancedStruct = NamedProperty.DataPinProperty;

			return true;
		}
	}

	return Super::TryFindPropertyByRemappedPinName(RemappedPinName, OutFoundProperty, OutFoundInstancedStruct, InOutResult);
}

#if WITH_EDITOR
void UFlowNode_DefineProperties::AutoGenerateDataPins(TMap<FName, FName>& PinNameToBoundPropertyMap, TArray<FFlowPin>& InputDataPins, TArray<FFlowPin>& OutputDataPins) const
{
	for (const FFlowNamedDataPinProperty& DataPinProperty : NamedProperties)
	{
		if (DataPinProperty.IsValid())
		{
			PinNameToBoundPropertyMap.Add(DataPinProperty.Name, DataPinProperty.Name);

			if (DataPinProperty.IsInputProperty())
			{
				InputDataPins.AddUnique(DataPinProperty.CreateFlowPin());
			}
			else if (DataPinProperty.IsOutputProperty())
			{
				OutputDataPins.AddUnique(DataPinProperty.CreateFlowPin());
			}
			else
			{
				LogError(TEXT("DataPin must be either an Input or Output property!"));
			}
		}
	}
}

void UFlowNode_DefineProperties::PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChainEvent)
{
	Super::PostEditChangeChainProperty(PropertyChainEvent);

	if (PropertyChainEvent.PropertyChain.Num() == 0)
	{
		return;
	}

	auto& Property = PropertyChainEvent.PropertyChain.GetActiveMemberNode()->GetValue();

	// The DetailsCustomization for FFlowDataPinProperties isn't being called when using an InstancedStruct
	// so we need to call this refresh by hand...
	if (PropertyChainEvent.ChangeType == EPropertyChangeType::ValueSet &&
		Property->GetFName() == GET_MEMBER_NAME_CHECKED(FFlowDataPinOutputProperty_Enum, EnumName))
	{
		for (FFlowNamedDataPinProperty& NamedProperty : NamedProperties)
		{
			if (!NamedProperty.IsValid())
			{
				continue;
			}

			const FFlowDataPinProperty& FlowDataPinProperty = NamedProperty.DataPinProperty.Get();

			if (FlowDataPinProperty.GetFlowPinType() == EFlowPinType::Enum)
			{
				FFlowDataPinOutputProperty_Enum& EnumProperty = NamedProperty.DataPinProperty.GetMutable<FFlowDataPinOutputProperty_Enum>();
				EnumProperty.OnEnumNameChanged();
			}

			// We may need to manually call any PostEdit linked property updates here for future EFlowPinType values
			FLOW_ASSERT_ENUM_MAX(EFlowPinType, 16);
		}
	}

	constexpr EPropertyChangeType::Type RelevantChangeTypesForReconstructionMask =
		EPropertyChangeType::Unspecified |
		EPropertyChangeType::ArrayAdd |
		EPropertyChangeType::ArrayRemove |
		EPropertyChangeType::ArrayClear |
		EPropertyChangeType::ValueSet |
		EPropertyChangeType::Redirected |
		EPropertyChangeType::ArrayMove;

	const uint32 PropertyChangedTypeFlags = (PropertyChainEvent.ChangeType & RelevantChangeTypesForReconstructionMask);
	const bool bIsRelevantChangeTypeForReconstruction = PropertyChangedTypeFlags != 0;
	const bool bChangedOutputProperties = Property->GetFName() == GET_MEMBER_NAME_CHECKED(UFlowNode_DefineProperties, NamedProperties);
	if (bIsRelevantChangeTypeForReconstruction && bChangedOutputProperties)
	{
		OnReconstructionRequested.ExecuteIfBound();
	}
}
#endif // WITH_EDITOR

bool UFlowNode_DefineProperties::TryFormatTextWithNamedPropertiesAsParameters(const FText& FormatText, FText& OutFormattedText) const
{
	if (NamedProperties.IsEmpty())
	{
		return false;
	}

	FFormatNamedArguments Arguments;
	for (const FFlowNamedDataPinProperty& NamedProperty : NamedProperties)
	{
		if (!NamedProperty.Name.IsValid())
		{
			LogWarning(TEXT("Could not format text with a nameless named property"));
		}
		else if (!TryAddValueToFormatNamedArguments(NamedProperty, Arguments))
		{
			LogWarning(FString::Printf(TEXT("Could not format text for named property %s"), *NamedProperty.Name.ToString()));
		}
	}

	OutFormattedText = FText::Format(FormatText, Arguments);

	return true;
}
